---
title: "First exploration of RPG dataset"
author: Romain Frelat
date: today
format: 
  html:
    toc: true
execute:
  echo: false
  warning: false
---


```{r setup}
library(terra) |> suppressWarnings()
library(sf) |> suppressWarnings()
library(here) |> suppressWarnings()
library(mapview)
# Load home made functions
devtools::load_all()

datafolder <- here("data", "raw-data")
pts <- vect(here(datafolder, "all_points.gpkg"))
# Create an ID per site
pts$ID <- paste(pts$Study_ID, pts$Site, pts$Year, sep="_")
# crds(pts)[pts$ID %in% pts$ID[duplicated(pts$ID)],]
# remove duplicates
pts <- pts[!duplicated(pts$ID)]

# get department from IGN
# library(happign)
# pts_sf <- st_as_sf(pts)
# meta <- get_layers_metadata("wfs")
# meta$Name[grep("departement", meta$Name)]
# adm <- get_wfs(
#   pts_sf,
#   "ADMINEXPRESS-COG.LATEST:departement",
#   filename = here::here(datafolder, "departement.gpkg"),
#   overwrite = TRUE
# )
departments <- vect(here(datafolder, "departement.gpkg"))
```


## Identification of the case study

```{r}
pt_dep <- extract(departments, pts)
# merge columns in pts
pts_full <- cbind(pts, pt_dep)

n_points <- as.numeric(table(pts_full$code_insee))
n_study <- tapply(pts_full$Study_ID, pts_full$code_insee, function(x) {
  length(unique(x))
})
```

On October 2nd, the dataset consisted of ```r length(pts)``` field coordinates, spread over ```r length(n_points)``` French departments. Two departments seems to offer ideal case study (@fig-1) :   

- Ille-et-Vilaine (35) with 4 different datasets and 227 points;   
- Gironde (33) with 3 different datasets, and 338 points.  

```{r}
#| label: fig-1
#| fig-cap: "Distribution of the fields per department represented as the number of fields (x-axis) and the number of projects per department (y-axis). The numbers shown in the plot are the number of the department."
plot(
  n_points,
  n_study,
  type = "n",
  xlab = "Number of fields",
  ylab = "Number of projects"
)
sel = c(33, 35)
text(
  n_points,
  n_study,
  names(n_study),
  xpd = NA,
  font = ifelse(names(n_study) %in% sel, 2, 1)
)
```


```{r}
pts_35 <- pts[pt_dep$code_insee == "35", ]
pts_35 <- project(pts_35, "EPSG:2154")
# writeVector(pts_35, here::here(datafolder, "pts_35.gpkg"), overwrite = TRUE)

pts_33 <- pts[pt_dep$code_insee == "33", ]
pts_33 <- project(pts_33, "EPSG:2154")
# writeVector(pts_33, here::here(datafolder, "pts_33.gpkg"), overwrite = TRUE)
```


## Spatial coverage

### RPG sequence de culture

Let's try using the `RPG sequence de culture` from   

> Girault, Baptiste; Martin, Philippe, 2025, "Séquences de culture, France, 2015-2023", <https://doi.org/10.57745/VMYCYM>, Recherche Data Gouv, V2 

The main advantages are that (1) it is very easy to download (one file per department), (2) relatively light (100Mb per file), (3) can retrieve the full crop sequence (2015-2023) in a single operation.    
The main drawbacks are that (1) it doesn't contain `RPG complété` information (coordinates might fall outside the dataset) and (2) the fields are subdivided so it's harder to get information on field size.  

To get more information about the crop classes, the following companion dataset is needed:  

> Girault, Baptiste; Martin, Philippe, 2023, "Référentiel des cultures RPG", <https://doi.org/10.57745/FMP8GU>, Recherche Data Gouv, V1


```{r}
#| label: tbl-1
#| tbl-cap: "Number of fields in Ille-et-vilaine with information from RPG Sequences de culture (TRUE) or not (FALSE)"
rpg_35 <- vect(here(datafolder, "d35.gpkg"))
pt_rpg_35 <- extract(rpg_35, pts_35)
table(!is.na(pt_rpg_35$id_unique), pts_35$Study_ID) |> knitr::kable()
```

```{r}
#| label: tbl-2
#| tbl-cap: "Number of fields in Gironde with information from RPG Sequences de culture (TRUE) or not (FALSE)"
rpg_33 <- vect(here(datafolder, "d33.gpkg"))
pt_rpg_33 <- extract(rpg_33, pts_33)
table(!is.na(pt_rpg_33$id_unique), pts_33$Study_ID) |> knitr::kable()
```

The coverage of `RPG sequence de culture` is very good in Ille-et-vilaine (@tbl-1,  only ```r sum(is.na(pt_rpg_35$id_unique))``` missing fields), but less complete in Gironde (@tbl-2, with ```r sum(is.na(pt_rpg_33$id_unique))``` missing fields).


### RPG Complete

A team from INRAE are completing the RPG with fields that are not included originally. For each of these fields, the crop sequence is also provided since 2016.

The [RPG complete 2023](https://entrepot.recherche.data.gouv.fr/dataverse/rpg_complete_2023
https://entrepot.recherche.data.gouv.fr/dataverse/rpg_complete_2019) is not fully released yet (missing regions), so we will explore the [dataset of 2022](https://entrepot.recherche.data.gouv.fr/dataverse/rpg_complete_2022).  

> Cantelaube, Pierre; Lardot, Benjamin, 2024, "RPG complété 2022 Région Nouvelle-Aquitaine", <https://doi.org/10.57745/6FNRWO>, Recherche Data Gouv, V5  (d33: 47Mb compressed, 171Mb extracted)    
> Cantelaube, Pierre; Lardot, Benjamin, 2024, "RPG complété 2022 Région Bretagne", <https://doi.org/10.57745/DL3O6C>, Recherche Data Gouv, V1 (d35, 53Mb compressed, 180Mb extracted)  

```{r}
#| label: tbl-3
#| tbl-cap: "Number of fields in Ille-et-vilaine with information from RPG"
rpg_35_c <- vect(here(datafolder, "rpg_complete_2022_d35.shp"))
pt_rpgc_35 <- extract(rpg_35_c, pts_35)

pts_35$cover <- ifelse(
  is.na(pt_rpg_35$id_unique),
  ifelse(is.na(pt_rpgc_35$id_parc), "None", "RPG Complete"),
  "RPG"
)
table(pts_35$cover, pts_35$Study_ID) |> knitr::kable()
```

```{r}
#| label: tbl-4
#| tbl-cap: "Number of fields in Gironde with information from RPG Complété"
rpg_33_c <- vect(here(datafolder, "rpg_complete_2022_d33.shp"))
pt_rpgc_33 <- extract(rpg_33_c, pts_33)

pts_33$cover <- ifelse(
  is.na(pt_rpg_33$id_unique),
  ifelse(is.na(pt_rpgc_33$id_parc), "None", "RPG Complete"),
  "RPG"
)
table(pts_33$cover, pts_33$Study_ID) |> knitr::kable()
```

The RPG complete doesn`t solve all the issues of sites not fitting within agricultural fields (@tbl-3, @tbl-4)...  

A first visual exploration seems to indicate samplings from vineyard or forested areas (@fig-2, @fig-3).  


### Visual exploration
```{r}
#| label: fig-2
#| fig-cap: "Interactive map of the fields sampled in Gironde"
st_as_sf(pts_33) |>
  mapview(
    z = "cover",
    layer.name = "cover",
    map.types = c("Esri.WorldImagery", "OpenStreetMap")
  )
```


```{r}
#| label: fig-3
#| fig-cap: "Zoom in an area with multiple fields around Langon"
sub <- pts_33[
  pts_33$Site %in% c("Tri04C", "Tri02V", "33_2018_00002", "Tri06M")
]
# small missing: c("C10", "C05", "C06", "C07")
# medium:c("C06", "33_2022_00004", "33_2018_00003", "C10")
# large: c("C06", "V01", "M09", "Tri07C", "01C15")]
zoom <- vect(ext(sub) + 1000, crs = crs(pts_33))
rpgc_zoom <- crop(rpg_33_c, zoom)
rpg_zoom <- crop(rpg_33, zoom)
pts_zoom <- crop(pts_33, zoom)
mapview(
  rpg_zoom,
  color = "blue",
  alpha.regions = 0,
  map.types = c("Esri.WorldImagery", "OpenStreetMap")
) +
  mapview(rpgc_zoom, color = "red", col.regions = "red", alpha.regions = 0) +
  mapview(st_as_sf(pts_zoom), z = "cover", layer.name = "cover") +
  mapview(
    zoom,
    color = "black",
    col.regions = "black",
    alpha.regions = 0,
    layer.name = "extent"
  )
```

Fields in `RPG sequence de culture` and `RPG complete` are very patchy from @fig-3. We will complete the data with OSO land cover (see [land cover exploration]((https://funbiodiv.github.io/gis-diversification/analysis/02_land_cover.html))).  

**TO BE DISCUSSED**:   
- should we remove points that don't fit within a RPG / RPG complété field (e.g. incorrect coordinates, or non-interesting sampling site - urban or forest)? 


## Crop rotation (2015-2023)

Let's zoom in Ille-et-vilaine (35) with the `RPG sequence de culture` on crop rotation.

The most common crops are shown in @tbl-5.   

```{r}
#| label: tbl-5
#| tbl-cap: "Top ten crop in the fields sampled in Ille-et-vilaine"
ref_rpg <- read.csv(here(datafolder, "ref_rpg.csv"))

info_rot <- pt_rpg_35[, grep("cult", names(pt_rpg_35))]

pop_crop <- as.data.frame(table(unlist(info_rot)))
pop_crop$Nom <- ref_rpg$nom_culture[match(pop_crop$Var1, ref_rpg$code_culture)]
pop_crop[order(pop_crop$Freq, decreasing = TRUE)[1:10], ] |> knitr::kable()
```

The most common crop sequences are shown in @tbl-6. 

```{r}
#| label: tbl-6
#| tbl-cap: "Top ten crop sequences in the fields sampled in Ille-et-vilaine"

rotation <- apply(info_rot, 1, concat)
head(sort(table(rotation), decreasing = TRUE), 10) |> knitr::kable()
```

The most common crop varieties cultivated on the same fields are shown in @tbl-7. 

```{r}
#| label: tbl-7
#| tbl-cap: "Top ten crop diversity on field (unique crop, independent of the order)"
u_rotation <- apply(info_rot, 1, paste_unique)
head(sort(table(u_rotation), decreasing = TRUE), 10) |> knitr::kable()
```

```{r}
#| label: fig-4
#| fig-cap: "Distribution of the number of different crops cultivated per field in the period 2015-2023"
n_rot <- apply(info_rot, 1, lunique)

barplot(table(n_rot), xlab = "Number of crops", ylab = "Number of fields")
```

On most fields, there are between 3 and 4 different crops cultivated within the 2015-2023 period. 

**TO BE DISCUSSED**:    
- decide whether we simplify the crop types (e.g. merging MIE and MIS)   
- is the order of the successive crops important? (e.g. CZH,BTH,MIE different from BTH,CZH,MIE ?)

**TO BE IMPROVED**:  
- subset the crop sequence for each field between N-5 and N. 



## Field size


### Perimeter 

This is a tricky operation, because sub-fields do not overlap properly (different edges), and sometimes they have complex geometry. So far, the best solution that I found is to:   

1. aggregate (or dissolve) with `aggregate()`  
2. merge non touching polygons by calculating convex hull `hull(type = "concave_length")`  
3. and simplify the geometry to remove some unecessary complicated geometries with `simplifyGeom()`  

The perimeter is highly sensible to all theses steps (the area much less).

```{r}
#| label: fig-6
#| fig-cap: "Exploration of how to merge sub-fields"
df35 <- as.data.frame(rpg_35)

par(mfrow = c(3, 3))
# issue with i = 113
# instead of 1:nrow(pt_rpg_35), select ok examples
# okids <- which(as.numeric(pts_35$Year) > 2014 & !is.na(pt_rpg_35$id_unique))
# for (i in sample(okids, 9)) {
n = 1
i = 1
while (n < 10) {
  # get year of point i (take only the first one for now)
  yri <- substr(pts_35$Year[i], 1, 4)
  coli <- paste0("parcel", yri)
  # get the parcel id that intersect the point
  idi <- pt_rpg_35[i, coli]
  if (!is.na(idi) & sum(df35[, coli] == idi) > 1) {
    # get pacrel from RPG
    pci <- rpg_35[df35[, coli] == idi]
    # aggregate doesn't works because holes between polygons
    agg_pci <- aggregate(pci)
    # convex hull works but have to fine tune the parameters
    # have to be check if far way polygons
    hu_pci <- hull(agg_pci, type = "concave_length")
    # simplify helps a little
    si_pci <- simplifyGeom(hu_pci, preserveTopology = FALSE)

    plot(pci, main=pts_35$ID[i])
    plot(agg_pci, border = "blue", add = TRUE)
    plot(hu_pci, border = "red", add = TRUE)
    plot(si_pci, border = "green", add = TRUE)
    n = n + 1
  }
  i = i + 1
}
#    expanse(si_pci)
#    perim(si_pci)
```



```{r}
#| label: fig-7
#| fig-cap: "Exploration of how to merge sub-fields"
df35 <- as.data.frame(rpg_35)

rpg_simple <- vect()
rpg_full <- vect()
for (i in 1:nrow(pt_rpg_35)) {
  # get year of point i (take only the first one for now)
  yri <- substr(pts_35$Year[i], 1, 4)
  if (yri %in% 2015:2023) {
    coli <- paste0("parcel", yri)
    # get the parcel id that intersect the point
    idi <- pt_rpg_35[i, coli]
    if (!is.na(idi)) {
      # get pacrel from RPG
      pci <- rpg_35[df35[, coli] == idi]
      # aggregate doesn't properly works because holes between polygons
      agg_pci <- aggregate(pci, atts = data.frame(df35[i, ]))
      # convex hull works but have to fine tune the parameters
      # have to be check if far way polygons
      hu_pci <- hull(agg_pci, type = "concave_length")
      # simplify helps a little bit more
      si_pci <- simplifyGeom(hu_pci, preserveTopology = FALSE)
      # add to rpg_simple
      rpg_simple <- rbind(
        rpg_simple,
        cbind(si_pci, pts_35[i, ], pt_rpg_35[i, ])
      )

      # keep track of original data
      rpg_full <- rbind(
        rpg_full,
        cbind(pci, pts_35[rep(i, length(pci))])
      )
    }
  }
}

# writeVector(rpg_simple, here::here(datafolder, "rpg_aggregated_field_35.gpkg"), overwrite = TRUE)
# writeVector(rpg_full, here::here(datafolder, "rpg_all_fields_35.gpkg"), overwrite = TRUE)
# mapview::mapview(rpg_full)
```

Number of sites with fields found in `RPG sequence de culture`
```{r}
table(pt_rpg_35$id_unique %in% rpg_simple$id_unique)
pts_35$hasfield <- pt_rpg_35$id_unique %in% rpg_simple$id_unique
```

Summary of the area of fields (in $ha$)
```{r}
rpg_simple$area_ha <- expanse(rpg_simple) * 0.0001
summary(rpg_simple$area_ha)
```

Summary of the perimeter of fields (in $m$)
```{r}
rpg_simple$perimeter_m <- perim(rpg_simple)
summary(rpg_simple$perimeter_m)
```

```{r}
#| label: fig-8
#| fig-cap: "Interactive map with the sites and the corresponding field from RPG sequence de culture."
mapview(
  st_as_sf(pts_35),
  z = "hasfield",
  layer.name = "cover",
  map.types = c("Esri.WorldImagery", "OpenStreetMap")
) +
  mapview(rpg_simple, color = "blue", col.regions = "blue", alpha.regions = 0.4)

```


**TO BE DISCUSSED**:   

- are the areas and perimeters within expected range? what about the shape of the fields?   
- how do we deal with issues identified visually, e.g. BIOHME_43_2020 (multiple fields + road)?



## BD Haie and buffer

Let's explore the dataset from BD Haie v2 mars 2024 from <https://geoservices.ign.fr/bdhaie> (1.5Gb compressed, 6.8Gb). BD Haie v2 is derived from images of the period 2020-2022 which is a better fit to our dataset than v1 based on images from 2011-2024.

```{r}
# haie needs to be filtered to load fast
ext_35 <- vect(ext(pts_35) + 1000, crs = crs(pts_35))
haie <- vect(here(datafolder, "haie.gpkg"), filter = ext_35)
```

### Visualization

Let's zoom in an area around Pleine-Fougères to visualize the hedges in BD HAIE (@fig-9).

```{r}
#| label: fig-9
#| fig-cap: "Interactive map with the hedges and the sampled fields around Trans-la-Foret"
sub <- pts_35[
  pts_35$Site %in% c("86", "157", "149", "20") & pts_35$Study_ID == "BISCO"
]
zoom <- vect(ext(sub) + 1000, crs = crs(pts_35))
haie_zoom <- crop(haie, zoom)
fields_zoom <- crop(rpg_simple, zoom)

mapview(
  haie_zoom,
  color = "black",
  alpha.regions = 0,
  map.types = c("Esri.WorldImagery", "OpenStreetMap")
) +
  mapview(
    fields_zoom,
    color = "blue",
    col.regions = "blue",
    alpha.regions = 0.4
  )

```
  
  
### Length of hedges
    
Summary of the length of hedges in the sampled field (m)
```{r}
haie_0 <- intersect(haie, rpg_simple)
length_haie <- tapply(perim(haie_0), haie_0$ID, sum)
summary(length_haie[rpg_simple$ID]) 
```


Summary of the density of hedges in the sampled field (km/ha)
```{r}
density_haie <-length_haie[rpg_simple$ID]/expanse(rpg_simple)*10
summary(density_haie)
```


```{r}
#| label: fig-10
#| fig-cap: "Relation between field size and length of hedges within the field"
plot(expanse(rpg_simple)/10000, length_haie[rpg_simple$ID], xlab="Field size (ha)", ylab="Length of hedges (m)")
```

Some fields (N=```r sum(is.na(density_haie))```) don't have hedges around the field (e.g. @fig-11)

```{r}
#| label: fig-11
#| fig-cap: "Example of a field with no hedges within the cropping area"
no_hedge <- which(!rpg_simple$ID%in%names(length_haie))[2]
plot(rpg_simple[no_hedge])
plot(haie, add=TRUE, col="red")
legend("bottomleft", legend=c("field", "hedge"), col=c("black", "red"), lwd=1, xpd=NA)
```


### Buffers

Let's create four different buffers: 10m, 500m, 1000m, and 1500m (@fig-12) and calculate the density of hedge within the buffer (@fig-13).

```{r}
#| label: fig-12
#| fig-cap: "Representation of the different buffer size"
field_buff1 <- buffer(rpg_simple, 1)
field_buff2 <- buffer(rpg_simple, 2)
field_buff5 <- buffer(rpg_simple, 5)
field_buff10 <- buffer(rpg_simple, 10)

zoom <- vect(ext(field_buff10[1]), crs = crs(field_buff10))
haie_buffzoom <- crop(haie, zoom)

plot(field_buff10[1])
plot(field_buff5[1], add=TRUE, border="blue")
plot(field_buff2[1], add=TRUE, border="red")
plot(field_buff1[1], add=TRUE, border = "darkgreen")
plot(rpg_simple[1], add=TRUE, col="grey")
plot(haie_buffzoom, col="green", add=TRUE, lwd=2)
legend("center", legend=c(10, 5, 2, 1), col=c("black", "blue", "red", "darkgreen"), lwd=1, title="Buffer size")
```


```{r}
#| label: fig-13
#| fig-cap: "Relationships among hedge density calculated with different buffer sizes (10m, 5m, 2m, 1m, and no buffer)."

haie_10 <- intersect(haie, field_buff10)
length_10 <- tapply(perim(haie_10), haie_10$ID, sum)

haie_5 <- intersect(haie, field_buff5)
length_5 <- tapply(perim(haie_5), haie_5$ID, sum)

haie_2 <- intersect(haie, field_buff2)
length_2 <- tapply(perim(haie_2), haie_2$ID, sum)

haie_1 <- intersect(haie, field_buff1)
length_1 <- tapply(perim(haie_1), haie_1$ID, sum)

#in km/ha (0.1 m/m2) 
density_buffer <- data.frame(
  b10 = length_10[rpg_simple$ID]/expanse(field_buff10)*10,
  b5 = length_5[rpg_simple$ID]/expanse(field_buff5)*10,
  b2 = length_2[rpg_simple$ID]/expanse(field_buff2)*10,
  b1 = length_1[rpg_simple$ID]/expanse(field_buff1)*10,
  b0 = length_haie[rpg_simple$ID]/expanse(rpg_simple)*10
)

pairs(density_buffer, lower.panel = panel.smooth, upper.panel = panel.cor)
```

The local hedge density might be better estimated with a buffer of 10m around the field (it will solve the issue seen in @fig-11). 

**TO BE DISCUSSED**:   

- are the hedge density within expected range?
- from @fig-9, it seems that not all hedges are mapped, but maybe only the *interesting* one. Are the results representing what we want? or should we complete with another dataset?