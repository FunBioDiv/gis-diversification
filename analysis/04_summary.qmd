---
title: "Calculation of diversification indicators and other covariates"
author: Romain Frelat
date: today
format: 
  html:
    toc: true
execute:
  echo: false
  warning: false
---


## Summary

| **Indicator**                              | **Data**             | **Format**      |
| ------------------------------------------ | -------------------- | --------------- |
| perimeter and area of the field            | RPG                  | vectoriel       |
| mean field size within buffer              | RPG                  | vectoriel       |
| hedgerows length around field              | RPG + BD haies       | vectoriel       |
| crop rotation (N-5:N)                      | RPG + OSO            | raster          |
| % land cover within buffer                 | RPG + OSO            | raster          |
| *density of bordures*                      | RPG + OSO            | raster          | 

Data description:  

- **Registre Parcellaire Graphique (RPG)**(45Gb): annual field crop data for the period 2007-2023 available at France scale on IGN website: <https://geoservices.ign.fr/rpg>. Definition of field (parcelles) are coherent only in the recent period 2015-2023.    
- **Carte d’occupation des sols du CES OSO – THEIA (OSO)**(6.6Gb): annual land cover data for the period 2016-2024. Available for France in raster format and 10m resolution <https://doi.org/10.57745/UZ2NJ7>. Official access through the CNES website <https://geodes-portal.cnes.fr>.   
- **BD Haies v2** (6.8Gb): hedgerows dataset for France available on the IGN website: <https://geoservices.ign.fr/bdhaie>. BD Haie v2 was produced from satellite images of 2020-2022 (which is a better fit to our data than v1 from images of 2011-2014).  


## Field observations

```{r}
#| label: tbl-1
#| tbl-cap: "Number of observations per year and per project"
suppressWarnings({
  library(terra)
  library(sf)
  library(here)
  library(mapview)
  library(leaflet)
  library(tmap)
  library(plotly)
})

# Load home made functions
devtools::load_all()

datafolder <- here("data", "raw-data")

pts <- vect(here(datafolder, "fields_FR.gpkg"), "fields_FR")

# Create an ID per site
pts$ID <- paste(pts$Study_ID, pts$Site, pts$Year, sep = "_")

# crds(pts)[pts$ID %in% pts$ID[duplicated(pts$ID)],]
# remove duplicates
pts <- pts[!duplicated(pts$ID)]

# raster indicators
indr <- read.csv(here("data", "derived-data", "raster_indicators.csv"))

# rpg and oso classes
ref <- read.csv(here("data", "derived-data", "RPG-OSO_classes.csv"))

# vector indicators
indv <- read.csv(here("data", "derived-data", "vector_indicators.csv"))
# table(indv$Study_ID) == table(pts$Study_ID)

n_year <- as.data.frame.matrix(table(pts$Study_ID, pts$Year))
n_year$TOTAL <- rowSums(n_year)
n_year['TOTAL', ] <- colSums(n_year)

knitr::kable(n_year)
```

```{r}
# remove outside year range
pts <- pts[pts$Year %in% 2016:2023]
```

Because of data availability (RPG is not released yet for 2024 and OSO is not available before 2016), we will only focus on the period 2016-2023. There were ```r nrow(pts)``` observations made between 2016 and 2023.

```{r}
#| label: fig-1
#| fig-cap: "Map of field observations"
tmap_mode("view")
tm_basemap("OpenStreetMap") +
  tm_shape(pts, is.main = TRUE) +
  tm_symbols(
    fill = "Study_ID",
    fill.scale = tm_scale_categorical(
      values = "cols4all.friendly13",
      values.repeat = FALSE
    )
  ) +
  tm_view(
    set_zoom_limits = c(3, 8),
    set_view = c(mean(ext(pts)[1:2]), mean(ext(pts)[3:4]), zoom = 5)
  )

# the easy solution
# m0 <- mapview(pts, zcol = "Study_ID")
# m0@map |>
#   addTiles(
#     options = providerTileOptions(minZoom = 3, maxZoom = 10)
#   )
# more complex solution
# pal <- leaflet::colorFactor("viridis", domain = NULL)
# keepPal <- pal(sort(unique(pts$Study_ID)))
# names(keepPal) <- sort(unique(pts$Study_ID))
# stablePal <- function(x) {
#   return(as.character(keepPal[x]))
# }
# shp_popup <- paste0(pts$Study_ID, "<br>", pts$Site)
# leaflet(pts) |>
#   addTiles(
#     options = providerTileOptions(minZoom = 3, maxZoom = 10)
#   ) |>
#   addCircleMarkers(
#     data = pts,
#     fillColor = ~ stablePal(Study_ID),
#     fillOpacity = 0.8,
#     color = ~ stablePal(Study_ID),
#     weight = 0.1,
#     popup = shp_popup
#   ) |>
#   addLegend(
#     labels = sort(unique(pts$Study_ID)),
#     position = "bottomleft",
#     color = stablePal(sort(unique(pts$Study_ID)))
#   ) |>
#   setView(
#     mean(ext(pts)[1:2]),
#     mean(ext(pts)[3:4]),
#     zoom = 5
#   )
```


## Indicators from vector datasets

### Identification of the crop field in RPG

```{r}
#| label: tbl-2
#| tbl-cap: "Number of observations in fields from RPG"

in_rpg <- data.frame(
  "Nobs" = as.numeric(table(indv$Study_ID)),
  "in_RPG" = table(indv$Study_ID, is.na(indv$ID_PARCEL))[, 1]
)
in_rpg$Perc <- round(in_rpg$in_RPG / in_rpg$Nobs * 100, 2)

knitr::kable(in_rpg)
```

In total, ```r round(sum(!is.na(indv$ID_PARCEL)) / nrow(indv) * 100)``` % of the fields observations are covered by RPG data. There are large disparities among projects with `SEBIOPAG_VcG`, `MUESLI` and `LepiBats` having a lower coverage than 60%. The project `DURUM_MIX_GM` has only one coordinates leading to the entrance of the Institut Agro-Montpellier.


```{r}
#| label: fig-2
#| fig-cap: "Case of SEBIOPAG_VcG observations in 2023 with overlaied RPG"
pts_vcg <- pts[pts$Study_ID == "SEBIOPAG_VcG" & pts$Year == "2023"]
pts_vcg$in_RPG <- !is.na(indv$ID_PARCEL[match(pts_vcg$ID, indv$ID)])

#fmt:skip
rpg_R73_2023 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = project(pts_vcg, "EPSG:2154")
)

mapview(pts_vcg, zcol = "in_RPG", layer.name = "in_RPG") +
  mapview(rpg_R73_2023, alpha = 0.5, alpha.regions = 0.3)

# pts_durum <- pts[pts$Study_ID == "LepiBats"]
# pts_durum <- pts[pts$Study_ID == "DURUM_MIX_GM"]
```


**To be discussed:**   

Some coordinates were taken at the edge or on the boundary of the field, so it is not possible to clearly identify the field. In such case, should we consider the closest field within a distance threshold (e.g. 10m)?


### Field size

```{r}
#| label: tbl-3
#| tbl-cap: "Summary statistics per project of the area (in ha) of crop fields"

# size <- cbind(
#   "Area_ha" = summary(indv$Area_ha),
#   "Perim_m" = summary(indv$Perim_m)
# )
# knitr::kable(round(size, 2))

sum_area <- sapply(
  tapply(indv$Area_ha, indv$Study_ID, summary),
  function(x) x[1:6]
)
# remove DURUM_MIX_GM
sum_area <- sum_area[, !is.na(sum_area[1, ])]

knitr::kable(round(sum_area, 2))
```

```{r}
#| label: tbl-4
#| tbl-cap: "Summary statistics per project of the perimeter (in m) of crop fields"
sum_area <- sapply(
  tapply(indv$Area_ha, indv$Study_ID, summary),
  function(x) x[1:6]
)
# remove DURUM_MIX_GM
sum_area <- sum_area[, !is.na(sum_area[1, ])]

knitr::kable(round(sum_area, 2))
```

```{r}
#| label: fig-3
#| fig-cap: "Relation between area and perimeter"
plot(indv$Area_ha, indv$Perim_m, xlab = "Area (ha)", ylab = "Perimeter (m)")
```

There is a strong relation between area and perimeter (@fig-3). In median, field size is ```r round(median(indv$Area_ha, na.rm=TRUE),1)``` ha and field perimeter is ```r round(median(indv$Perim_m, na.rm=TRUE),0)```m.  

**Outliers**

```{r}
# load matching rpg data
rpg_fields <- vect(here("data", "derived-data", "vector_parcels.gpkg"))
# for matching image to satellite image
ind23 <- indv[indv$Year == 2023, ]
```

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-4
#| fig-cap: "Abnormally large perimeter"
#fmt: skip
maxF <- rpg_fields[rpg_fields$ID_PARCEL == ind23$ID_PARCEL[which.max(ind23$Perim_m)]]
maxP <- pts[pts$ID == ind23$ID[which.max(ind23$Perim_m)]]
mapview(maxF) + mapview(maxP) # not up to date
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-5
#| fig-cap: "Abnormally small field"
#fmt: skip
minF <- rpg_fields[rpg_fields$ID_PARCEL == ind23$ID_PARCEL[which.min(ind23$Area_ha)]]
minP <- pts[pts$ID == ind23$ID[which.min(ind23$Area_ha)]]
mapview(minF) + mapview(minP) # not up to date

# par(mfrow = c(10, 10), mar = c(0, 0, 0, 0))
# for (i in sample(1:nrow(rpg_fields), size = 100)) {
#   plot(rpg_fields[i, ], axes = FALSE)
#   text(crds(centroids(rpg_fields[i, ])), rpg_fields$SURF_PARC[i])
# }
```

:::

::::

**To be discussed:**  
Some fields are defined as ```r ref$nom[ref$original_code == "BOR"]``` which are not field but borders (as in @fig-5). Should we remove fields from RPG that are not agricultural before running the calculations?


### Hedgerows length

Using the field as defined by RPG, we can calculate the length of hedgerows from BD Haies that intersect the field (+ a small buffer).

```{r}
#| label: tbl-5
#| tbl-cap: "Summary statistics of the hedgerows length (in m) within different buffer size around the field"
buff_hedge <- cbind(
  "B_0m" = summary(indv$Length_haie_0_m),
  "B_5m" = summary(indv$Length_haie_5_m),
  "B_10m" = summary(indv$Length_haie_10_m)
)

#fmt: skip
PercWithHedges <- c(
  sum(indv$Length_haie_0_m > 0, na.rm = TRUE),
  sum(indv$Length_haie_5_m > 0, na.rm = TRUE),
  sum(indv$Length_haie_10_m > 0, na.rm = TRUE)
) / sum(!is.na(indv$Length_haie_0_m)) * 100

buff_hedge <- rbind(buff_hedge, PercWithHedges)

knitr::kable(round(buff_hedge, 2))
```

The ```r buff_hedge["NA's",1]``` NA's correspond to the observations from which no corresponding fields were found. Without buffer, ```r round(PercWithHedges[1])```% of fields have hedgerows within the field. This percentage increases up to ```r round(PercWithHedges[3])```% if we consider a 10m buffer around the field.  

```{r}
#| label: fig-6
#| fig-cap: "Correlation among hedgerows lengths per buffer size"
hedgelendth <- data.frame(
  "B_0m" = indv$Length_haie_0_m,
  "B_5m" = indv$Length_haie_5_m,
  "B_10m" = indv$Length_haie_10_m
)

pairs(hedgelendth, lower.panel = panel.smooth, upper.panel = panel.cor)
```

**Outliers**

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-7
#| fig-cap: "Field with hedgerows at 5m buffer"
#fmt: skip
ex1 <- which(indv$ID == indv$ID[indv$Length_haie_0_m == 0][which.max(indv$Length_haie_10_m[indv$Length_haie_0_m == 0])])
pts_ex1 <- pts[pts$ID == indv$ID[ex1]]
rpg_ex1 <- rpg_fields[rpg_fields$ID_PARCEL == indv$ID_PARCEL[ex1]]
r5_ex1 <- buffer(rpg_ex1, 5)
r10_ex1 <- buffer(rpg_ex1, 10)
haie_ex1 <- vect(
  here("data", "raw-data", "haie_2-0.gpkg"),
  filter = vect(ext(r10_ex1))
)

plot(r10_ex1, col = NA, border = "red", lty = 3)
plot(rpg_ex1, col = NA, border = "black", add = TRUE)
plot(r5_ex1, col = NA, border = "blue", lty = 2, add = TRUE)
plot(haie_ex1, col = "darkgreen", lwd = 3, add = TRUE)
plot(project(pts_ex1, crs(haie_ex1)), add = TRUE)
lab <- c(
  paste("B_0m:", round(indv$Length_haie_0_m[ex1]), "m"),
  paste("B_5m:", round(indv$Length_haie_5_m[ex1]), "m"),
  paste("B_10m:", round(indv$Length_haie_10_m[ex1]), "m")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("black", "blue", "red"),
  lty = 1:3,
  xpd = NA
)

```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-8
#| fig-cap: "Field with hedgerows at 5-10m"
#fmt: skip
ex2 <- which(indv$ID == indv$ID[indv$Length_haie_5_m == 0][which.max(indv$Length_haie_10_m[indv$Length_haie_5_m == 0])])
pts_ex2 <- pts[pts$ID == indv$ID[ex2]]
rpg_ex2 <- rpg_fields[rpg_fields$ID_PARCEL == indv$ID_PARCEL[ex2]]
r5_ex2 <- buffer(rpg_ex2, 5)
r10_ex2 <- buffer(rpg_ex2, 10)
haie_ex2 <- vect(
  here("data", "raw-data", "haie_2-0.gpkg"),
  filter = vect(ext(r10_ex2))
)

plot(r10_ex2, col = NA, border = "red", lty = 3)
plot(rpg_ex2, col = NA, border = "black", add = TRUE)
plot(r5_ex2, col = NA, border = "blue", lty = 2, add = TRUE)
plot(haie_ex2, col = "darkgreen", lwd = 3, add = TRUE)
plot(project(pts_ex2, crs(haie_ex2)), add = TRUE)
lab <- c(
  paste("B_0m:", round(indv$Length_haie_0_m[ex2]), "m"),
  paste("B_5m:", round(indv$Length_haie_5_m[ex2]), "m"),
  paste("B_10m:", round(indv$Length_haie_10_m[ex2]), "m")
)
legend(
  "topright",
  legend = lab,
  col = c("black", "blue", "red"),
  lty = 1:3,
  xpd = NA
)

```

:::

::::

**To be discussed:**    

- Which buffer size should we use to calculate the hedgerows lengths? Without buffer, it might be too restrictive, but is 10m to large, or not enough?  
- Should we consider the position of the field sampling when calculating the hedgerows length?  


### Field size within buffer
    
```{r}
#| label: tbl-6
#| tbl-cap: "Summary statistics of the field area (in ha) within different buffer size"
buff_size <- cbind(
  "B_500m" = summary(indv$Mean_fieldsize_500m_ha),
  "B_1000m" = summary(indv$Mean_fieldsize_1000m_ha),
  "B_1500m" = summary(indv$Mean_fieldsize_1500m_ha)
)

knitr::kable(round(buff_size, 2))
```

We see that some observations don't have crop field within 500m (N=13). To be checked whether those observations (listed in @tbl-7) were really made close to an agricultural field.

```{r}
#| label: tbl-7
#| tbl-cap: "Observations with no fields within a 500m buffer."
# table(indv$Study_ID, is.na(indv$Mean_fieldsize_500m_ha))
miss_b500 <- indv[is.na(indv$Mean_fieldsize_500m_ha), ]
miss_b500[
  order(miss_b500$Study_ID, miss_b500$Year),
  c("Study_ID", "Site", "Year")
] |>
  knitr::kable()
```

```{r}
#| label: fig-9
#| fig-cap: "Correlation among field areas per buffer size"
meansize <- data.frame(
  "B_500m" = indv$Mean_fieldsize_500m_ha,
  "B_1000m" = indv$Mean_fieldsize_1000m_ha,
  "B_1500m" = indv$Mean_fieldsize_1500m_ha
)

pairs(meansize, lower.panel = panel.smooth, upper.panel = panel.cor)
```

**Outliers**

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-10
#| fig-cap: "Highest average field size within 1500m buffer"
#fmt: skip
ex1 <-  which(indv$ID == indv$ID[indv$Year == 2023][which.max(indv$Mean_fieldsize_1500m_ha[indv$Year == 2023])])

pts_ex1 <- project(pts[pts$ID == indv$ID[ex1]], crs(haie_ex1))
b500_ex1 <- buffer(pts_ex1, 500)
b1000_ex1 <- buffer(pts_ex1, 1000)
b1500_ex1 <- buffer(pts_ex1, 1500)

rpg_ex1 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex1
)

plot(rpg_ex1, col = NA, border = "black", main = indv$ID[ex1])
plot(b1500_ex1, col = NA, border = "red", add = TRUE)
plot(b1000_ex1, col = NA, border = "blue", add = TRUE)
plot(b500_ex1, col = NA, border = "green", add = TRUE)
plot(pts_ex1, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex1], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex1], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex1], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-11
#| fig-cap: "Lowest average field size within 1500m buffer"
#fmt: skip
ex2 <-  which(indv$ID == indv$ID[indv$Year == 2023][which.min(indv$Mean_fieldsize_1500m_ha[indv$Year == 2023])])

pts_ex2 <- project(pts[pts$ID == indv$ID[ex2]], crs(haie_ex2))
b500_ex2 <- buffer(pts_ex2, 500)
b1000_ex2 <- buffer(pts_ex2, 1000)
b1500_ex2 <- buffer(pts_ex2, 1500)

rpg_ex2 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex2
)

plot(rpg_ex2, col = NA, border = "black", main = indv$ID[ex2])
plot(b1500_ex2, col = NA, border = "red", add = TRUE)
plot(b1000_ex2, col = NA, border = "blue", add = TRUE)
plot(b500_ex2, col = NA, border = "green", add = TRUE)
plot(pts_ex2, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex2], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex2], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex2], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

::::


::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-12
#| fig-cap: "Large differences between 1000 and 1500m buffer"
var1 <- abs(indv$Mean_fieldsize_1500m_ha - indv$Mean_fieldsize_1000m_ha) /
  (indv$Mean_fieldsize_1500m_ha + indv$Mean_fieldsize_1000m_ha)

whom <- indv$Year == 2023 & !is.na(indv$ID_PARCEL)
ex3 <- which(indv$ID == indv$ID[whom][which.max(var1[whom])])

pts_ex3 <- project(pts[pts$ID == indv$ID[ex3]], "EPSG:2154")
b500_ex3 <- buffer(pts_ex3, 500)
b1000_ex3 <- buffer(pts_ex3, 1000)
b1500_ex3 <- buffer(pts_ex3, 1500)

rpg_ex3 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex3
)

plot(rpg_ex3, col = NA, border = "black", main = indv$ID[ex3])
plot(b1500_ex3, col = NA, border = "red", add = TRUE)
plot(b1000_ex3, col = NA, border = "blue", add = TRUE)
plot(b500_ex3, col = NA, border = "green", add = TRUE)
plot(pts_ex3, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex3], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex3], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex3], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-13
#| fig-cap: "Large differences between 500 and 1000m buffer"
var2 <- abs(indv$Mean_fieldsize_1500m_ha - indv$Mean_fieldsize_500m_ha) /
  (indv$Mean_fieldsize_1500m_ha + indv$Mean_fieldsize_500m_ha)

whom <- indv$Year == 2023 &
  !is.na(indv$ID_PARCEL) &
  indv$Study_ID != indv$Study_ID[ex3]
ex4 <- which(indv$ID == indv$ID[whom][which.max(var2[whom])])

pts_ex4 <- project(pts[pts$ID == indv$ID[ex4]], "EPSG:2154")
b500_ex4 <- buffer(pts_ex4, 500)
b1000_ex4 <- buffer(pts_ex4, 1000)
b1500_ex4 <- buffer(pts_ex4, 1500)

rpg_ex4 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex4
)

plot(rpg_ex4, col = NA, border = "black", main = indv$ID[ex4])
plot(b1500_ex4, col = NA, border = "red", add = TRUE)
plot(b1000_ex4, col = NA, border = "blue", add = TRUE)
plot(b500_ex4, col = NA, border = "green", add = TRUE)
plot(pts_ex4, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex4], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex4], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex4], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

::::


**Summary and questions about vector indicators**:   

- Most observations fit within RPG dataset (@tbl-2).    
- But some coordinates were taken at the very edges of field (@fig-2), so we might need to identify the closest field instead (and add a distance threshold, e.g. 10m).  
- Adding the RPG complété require more data processing, and in any case it won't cover all observations (but it will complete some wineyards). The RPG classes might also be less consistent within our timeframe and would require to be further checks.
- We might need to exclude some fields from RPG (e.g. Bordure, Bande tampon, Culture sous serre, Bois paturés, Surface non agricole, Truffière) to only includes crop fields that are relevant for us.
- The position of the observations within the field might influence the results (influence of hedgerows, or of agricultural practices). We might want to add an indicator reflecting the distance to the center of the field and/or the distance to the closest field boundary?  


## Indicators from raster datasets (RPG+OSO)

### Crop rotation (N-5:N)

```{r}

# make small correspondance table
ref$fullname <- paste(ref$source, ref$nom, sep = "_")
miniref <- ref[, c("new_code", "fullname")]
miniref <- miniref[!duplicated(miniref$new_code), ]
miniref <- miniref[!is.na(miniref$new_code), ]
miniref$fullname <- gsub("OSO_old_", "OSO_", miniref$fullname)

# transform with class names
lulc_id <- indr[, grep("lulc_", names(indr))]
lulc_class <- sapply(lulc_id, function(x) {
  miniref$fullname[match(x, miniref$new_code)]
})
lulc_group <- sapply(lulc_id, function(x) {
  ref$grp_label[match(x, ref$new_code)]
})
# numYr <- as.data.frame(table(pts$Year))
# names(numYr) <- c("Year", "Nobs")
# knitr::kable(numYr)

```

```{r}
#| label: tbl-8
#| tbl-cap: "Land cover data sources for the observations at year N to N-5"

info <- data.frame(
  "inRPG" = apply(lulc_id < 20000, 2, sum, na.rm = TRUE),
  "inOSO" = apply(lulc_id >= 20000, 2, sum, na.rm = TRUE),
  "NAs" = apply(is.na(lulc_id), 2, sum)
)
row.names(info)[-1] <- gsub("_N", "_N-", row.names(info)[-1])
knitr::kable(info)

# barplot(as.matrix(t(info)))
```

 
```{r}
#| label: tbl-9
#| tbl-cap: "Most commun land cover classes"
lulc_vec <- as.character(unlist(lulc_class[, 1])) #[,1]
info <- sort(table(lulc_vec), decreasing = TRUE)
info <- data.frame(info[1:sum(info > 20)])
names(info) <- c("landcover class", "N")
knitr::kable(info)
```

```{r}
#| label: fig-14
#| fig-cap: "Land cover at year N"
pts <- vect(here(datafolder, "fields_FR.gpkg"), "fields_FR")
pts$ID <- paste(pts$Study_ID, pts$Site, pts$Year, sep = "_")
indr$Study_ID <- pts$Study_ID[match(indr$ID, pts$ID)]
indr$Site <- pts$Site[match(indr$ID, pts$ID)]
indr$Year <- pts$Year[match(indr$ID, pts$ID)]
nlulc <- data.frame(table(lulc_group[, 1], indr$Study_ID))
names(nlulc) <- c("Cover", "Dataset", "N")
plot_ly(
  nlulc,
  x = ~Dataset,
  y = ~N,
  color = ~Cover,
  text = ~Cover,
  colors = pals::glasbey(lunique(nlulc$Cover)),
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack")
```



```{r}
#| label: fig-15
#| fig-cap: "Crop rotation in the period N:N-5"
nyear <- apply(lulc_id, 1, function(x) length(x[!is.na(x)]))
ncrop <- apply(lulc_id, 1, function(x) length(unique(x[!is.na(x)])))
ngroup <- apply(lulc_group, 1, function(x) length(unique(x[!is.na(x)])))

par(mfrow = c(1, 3))
barplot(
  table(nyear),
  xlab = "Number of years with land cover",
  ylab = "Number of observations",
  col = c(rep("grey70", 6), "black")
)
barplot(
  table(ncrop[nyear == 6]),
  xlab = "Number of crops in N:N-5",
  ylab = "Number of observations"
)
barplot(
  table(ngroup[nyear == 6]),
  xlab = "Number of crop groups in N:N-5",
  ylab = "Number of observations"
)


```

There are ```r sum(nyear == 6)``` observations with complete time series from year N to N-5. From these observations with complete rotation information, ```r sum(ngroup[nyear == 6] == 1)``` have the same crop group for the whole time period, while ```r sum(ngroup[nyear == 6] == 4)``` fields have four different crop groups in the past 6 years.

```{r}
#| label: tbl-10
#| tbl-cap: "Number of crop groups in the period N:N-5 for observations with complete data"
info <- table(ngroup[nyear == 6], indr$Study_ID[nyear == 6])
colnames(info) <- gsub("_", "<br>", colnames(info))
knitr::kable(info, row.names = TRUE)
```


```{r}
# comparaison landN vs indV
code_rpg <- indv$CODE_CULTU[match(indr$ID, indv$ID)]
lulc_rpg <- ref$new_code[match(code_rpg, ref$original_code)]
# table(indr$lulc_N == lulc_rpg, useNA = "ifany")
table(indr$lulc_N == lulc_rpg, useNA = "ifany")
# 33 out of 1045 : 3% = OK

# wrong <- which(indr$lulc_N != lulc_rpg)
# df <- data.frame(
#   "ID" = indr$ID,
#   "lulc_raster" = indr$lulc_N,
#   "rast_label" = ref$nom[match(indr$lulc_N, ref$new_code)],
#   "rast_group" = ref$grp_label[match(indr$lulc_N, ref$new_code)],
#   "lulc_vector" = lulc_rpg,
#   "vect_label" = ref$nom[match(lulc_rpg, ref$new_code)],
#   "vect_group" = ref$grp_label[match(lulc_rpg, ref$new_code)]
# )
# df <- df[wrong, ]

# pts_wrong <- pts[match(df$ID, pts$ID)]
# pts_wrong <- cbind(pts_wrong, df)
# mapview(pts_wrong)
```


### Land cover within buffer 

```{r}
#| label: tbl-11
#| tbl-cap: "Summary of the land cover buffer composition"

m500 <- grep("frac500", names(indr))
l500 <- gsub("frac500_", "", names(indr)[m500])
gr500 <- t(rowsum(
  t(indr[, m500]),
  ref$grp_label[match(l500, ref$new_code)],
  na.rm = TRUE
))

m1000 <- grep("frac1000", names(indr))
l1000 <- gsub("frac1000_", "", names(indr)[m1000])
gr1000 <- t(rowsum(
  t(indr[, m1000]),
  ref$grp_label[match(l1000, ref$new_code)],
  na.rm = TRUE
))

m1500 <- grep("frac1500", names(indr))
l1500 <- gsub("frac1500_", "", names(indr)[m1500])
gr1500 <- t(rowsum(
  t(indr[, m1500]),
  ref$grp_label[match(l1500, ref$new_code)],
  na.rm = TRUE
))


p_rpg <- c(
  mean(rowSums(indr[, m500[l500 < 20000]], na.rm = TRUE)),
  mean(rowSums(indr[, m1000[l1000 < 20000]], na.rm = TRUE)),
  mean(rowSums(indr[, m1500[l1500 < 20000]], na.rm = TRUE))
)
p_rpg <- round(p_rpg * 100)

info <- data.frame(
  "n_classes" = c(length(m500), length(m1000), length(m1500)),
  "av_perc_rpg" = p_rpg
)
row.names(info) <- c("buffer_500", "buffer_1000", "buffer_1500")
knitr::kable(t(info))
```


```{r}
#| label: fig-16
#| fig-cap: "Average land cover per buffer size"
# number of classes per buffer

mean_buffer <- data.frame(
  "B500" = apply(gr500, 2, sum, na.rm = TRUE) / sum(rowSums(gr500) > 0),
  "B1000" = apply(gr1000, 2, sum, na.rm = TRUE) / sum(rowSums(gr1000) > 0),
  "B1500" = apply(gr1500, 2, sum, na.rm = TRUE) / sum(rowSums(gr1500) > 0)
)
# simp_buffer <- mean_buffer[rowSums(mean_buffer) > 0.01, ] |>
#   t() |>
#   as.data.frame()

plotly_df(data.frame(t(mean_buffer)), xlab = "Buffer size")
```

::: {.panel-tabset}

## 500m 

```{r}
#| label: fig-17
#| fig-cap: "Average land cover per dataset with buffer of 500m"

pc500 <- data.frame(
  rowsum(gr500, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr500) > 0, indr$Study_ID, sum))
)

plotly_df(pc500)
```

## 1000m 

```{r}
#| label: fig-18
#| fig-cap: "Average land cover per dataset with buffer of 1000m"

pc1000 <- data.frame(
  rowsum(gr1000, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr1000) > 0, indr$Study_ID, sum))
)
# barplot(t(pc1000))
plotly_df(pc1000)
```

## 1500m 

```{r}
#| label: fig-19
#| fig-cap: "Average land cover per dataset with buffer of 1500m"

pc1500 <- data.frame(
  rowsum(gr1500, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr1500) > 0, indr$Study_ID, sum))
)

plotly_df(pc1500)
```

:::



### Density of bordures  

To be defined.
<!-- https://rdrr.io/cran/terra/man/boundaries.html -->


**Summary and questions about vector indicators**:   

- There are up to ```r info$n_classes[3]``` land cover in the RPG+OSO dataset. Here we simplified it using the Référentiel des cultures as an illustration. Before the extracted information can be usefull in the project, it requires further work on land cover class homogeneization.
- The edge density needs further thinking.