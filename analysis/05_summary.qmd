---
title: "Calculation of diversification indicators and other covariates"
author: Romain Frelat
date: today
format: 
  html:
    toc: true
execute:
  echo: false
  warning: false
---


## Summary

### Indicators 

|**Indicator**                               |**Data**              |**Format**       |
|:-------------------------------------------|:---------------------|:----------------|
| [perimeter and area of the field](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#field-size)            | RPG                  | vectoriel       |
| [hedgerows length around field](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#hedgerows-length)             | RPG + BD haies       | vectoriel       |
| [mean field size within buffer](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#field-size-within-buffer)              | RPG                  | vectoriel       |
| [crop rotation (N-5:N)](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#crop-rotation-n-5n)                      | RPG + OSO            | raster          |
| [% land cover within buffer](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#land-cover-within-buffer)                 | RPG + OSO            | raster          |
| [edge density](https://funbiodiv.github.io/gis-diversification/analysis/05_summary.html#edge-density)                               | RPG + OSO            | raster          | 


### Datasets 

- **Registre Parcellaire Graphique (RPG)**(45Gb): annual field crop data for the period 2007-2024 available at France scale on IGN website: <https://geoservices.ign.fr/rpg>. Definition of field (parcelles) are coherent only in the recent period 2015-2023.    
- **Carte d’occupation des sols du CES OSO – THEIA (OSO)**(6.6Gb): annual land cover data for the period 2016-2024. Available for France in raster format and 10m resolution <https://doi.org/10.57745/UZ2NJ7>. Official access through the CNES website <https://geodes-portal.cnes.fr>.   
- **BD Haies v2** (6.8Gb): hedgerows dataset for France available on the IGN website: <https://geoservices.ign.fr/bdhaie>. BD Haie v2 was produced from satellite images of 2020-2022 (which is a better fit to our data than v1 from images of 2011-2014).  

- *RPG complété*: add missing crop field data that was not officially reported in the Common Agricultural Policy (PAC in French acronym) so absent from the `RPG` dataset. It uses a combination of datasets from cadastre, IGN BD TOPO and OSO. Data is publicly available for the period 2018-2023 and it could be retrieve for the year 2016-2017 directly from Pierre Cantelaube (INRAE - ODR). The year 2024 will not be available in time for our project. The dataset is stored in multiple files per year and per regions or department <https://entrepot.recherche.data.gouv.fr/dataverse/rpg_complete_2022>. The main issue is that the definition of parcelle in `RPG` is different from cadastre in `RPG complété`, so it may bring biases in the vectorial calculations (based on the field definition). Additionally, it is heavy to process (download hundreds of files, merge them per year, ensure consistent classes with RPG) and it might bring only limited information on land cover. For this first exploration, **RPG complété was not included but the discussion is open**.

- [Land cover class harmonization](https://github.com/FunBioDiv/gis-diversification/raw/refs/heads/main/data/derived-data/RPG-OSO_classes.csv): list all classes from RPG and OSO and categorize them. This file must be double checked by expert and customized for the project objectives.

## Field observations

```{r}
suppressWarnings({
  library(terra)
  library(sf)
  library(here)
  library(mapview)
  library(leaflet)
  library(tmap)
  library(plotly)
})

# Load home made functions
devtools::load_all()

datafolder <- here("data", "raw-data")

pts <- vect(here(datafolder, "fields_FR.gpkg"), "fields_FR")

# Create an ID per site
pts$ID <- paste(pts$Study_ID, pts$Site, pts$Year, sep = "_")

# crds(pts)[pts$ID %in% pts$ID[duplicated(pts$ID)],]
# remove duplicates
pts <- pts[!duplicated(pts$ID)]

# raster indicators
indr <- read.csv(here("data", "derived-data", "raster_indicators.csv"))

# rpg and oso classes
ref <- read.csv(here("data", "derived-data", "RPG-OSO_classes.csv"))

# vector indicators
indv <- read.csv(here("data", "derived-data", "vector_indicators.csv"))
# for plotting Study_ID
indv$Study_Lab <- gsub("_", "\n", indv$Study_ID)
# table(indv$Study_ID) == table(pts$Study_ID)

# load matching rpg data
rpg_fields <- vect(here("data", "derived-data", "vector_parcels.gpkg"))

inde <- read.csv(here("data", "derived-data", "raster_edges.csv"))
inde$Study_ID <- gsub("DURUM_MIX_GM", "DURUM_MIXGM", inde$Study_ID)
inde$Study_Lab <- gsub("_", "\n", inde$Study_ID)
# error to be fixed in P04
inde <- inde[inde$e_RPG_50m != "LepiBats", ]
inde$e_RPG_50m <- as.numeric(inde$e_RPG_50m)

# rpg oso files
rast_files <- list.files(
  here("data", "derived-data"),
  pattern = "^RPG-OSO_.*\\.tif$",
  full.names = TRUE
)
rast_year <- substr(rast_files, nchar(rast_files) - 7, nchar(rast_files) - 4)
rpg_oso <- rast(rast_files)
names(rpg_oso) <- rast_year
```

::: {.panel-tabset}

## barplot
```{r}
#| label: fig-yearstudy
#| fig-cap: "Number of observations per year and per project"

df_year <- as.data.frame(table(pts$Study_ID, pts$Year))
names(df_year) <- c("Dataset", "Year", "Nobs")
plot_ly(
  df_year,
  x = ~Year,
  y = ~Nobs,
  color = ~Dataset,
  text = ~Dataset,
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack") %>%
  config(modeBarButtons = list(list("toImage")), displaylogo = FALSE)
```

## table
```{r}
#| label: tbl-yearstudy
#| tbl-cap: "Number of observations per year and per project"

n_year <- as.data.frame.matrix(table(pts$Study_ID, pts$Year))
n_year$TOTAL <- rowSums(n_year)
n_year['TOTAL', ] <- colSums(n_year)

knitr::kable(n_year)
```

:::

```{r}
#| label: fig-mapobs
#| fig-cap: "Map of field observations"
tmap_mode("view")
tm_basemap("OpenStreetMap") +
  tm_shape(pts, is.main = TRUE) +
  tm_symbols(
    fill = "Study_ID",
    fill.scale = tm_scale_categorical(
      values = "cols4all.friendly13",
      values.repeat = FALSE
    )
  ) +
  tm_view(
    set_zoom_limits = c(3, 8),
    set_view = c(mean(ext(pts)[1:2]), mean(ext(pts)[3:4]), zoom = 5)
  )
```


## Indicators from vector datasets

### Identification of the crop field in RPG

Because of data availability, we will only focus on the observations made in the period 2016-2023 (N=```r nrow(indv)```). *RPG 2024 was only released at the end of November 2025 and is not included yet*.  

We identified the crop field from RPG dataset corresponding to the observations based on the coordinates and the year of the samplings.

```{r}
#| label: tbl-inrpg
#| tbl-cap: "Number of observations in fields from RPG"

in_rpg <- data.frame(
  "Nobs" = as.numeric(table(indv$Study_ID)),
  "in_RPG" = table(indv$Study_ID, is.na(indv$ID_PARCEL))[, 1]
)
in_rpg$Perc <- round(in_rpg$in_RPG / in_rpg$Nobs * 100, 2)

knitr::kable(in_rpg)
```

In total, ```r round(sum(!is.na(indv$ID_PARCEL)) / nrow(indv) * 100)``` % of the fields observations are covered by RPG data. There are large disparities among projects with `SEBIOPAG_VcG`, `MUESLI` and `LepiBats` having a lower coverage than 60%. The project `DURUM_MIX_GM` has only one coordinates leading to the entrance of the Institut Agro-Montpellier.


```{r}
#| label: fig-outsebiopagvcg
#| fig-cap: "Case of SEBIOPAG_VcG observations in 2023 with overlaied RPG"
pts_vcg <- pts[pts$Study_ID == "SEBIOPAG_VcG" & pts$Year == "2023"]
pts_vcg$in_RPG <- !is.na(indv$ID_PARCEL[match(pts_vcg$ID, indv$ID)])

#fmt:skip
rpg_R73_2023 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = project(pts_vcg, "EPSG:2154")
)

mapview(pts_vcg, zcol = "in_RPG", layer.name = "in_RPG") +
  mapview(rpg_R73_2023, alpha = 0.5, alpha.regions = 0.3)

# pts_durum <- pts[pts$Study_ID == "LepiBats"]
# pts_durum <- pts[pts$Study_ID == "DURUM_MIX_GM"]
```


**To be discussed:**   

- Some coordinates were taken at the edge or on the boundary of the field (@fig-outsebiopagvcg), so it is not possible to clearly identify in which field they belong. In such case, using RPG complété will probably not help. Should we consider the closest field within a distance threshold (e.g. 10m)?


### Field size

We calculated the area and the perimeter of the crop fields corresponding to the samplings.

::: {.panel-tabset}

## boxplot 

```{r}
#| label: fig-boxareastudy
#| fig-cap: "Field area in ha per project. The dashed line show the median area."

par(mar = c(8, 4, 4, 1))
boxplot(
  indv$Area_ha ~ indv$Study_Lab,
  las = 2,
  ylab = "ha",
  xlab = "",
  main = "Crop field area"
)
abline(h = median(indv$Mean_fieldsize_500m_ha, na.rm = TRUE), lwd = 2, lty = 3)
```

## table

```{r}
#| label: tbl-areastudy
#| tbl-cap: "Summary statistics per project of the area (in ha) of crop fields"

# size <- cbind(
#   "Area_ha" = summary(indv$Area_ha),
#   "Perim_m" = summary(indv$Perim_m)
# )
# knitr::kable(round(size, 2))

sum_area <- sapply(
  tapply(indv$Area_ha, indv$Study_ID, summary),
  function(x) x[1:6]
)
# remove DURUM_MIX_GM
sum_area <- sum_area[, !is.na(sum_area[1, ])]

# colnames(sum_area) <- gsub("_", "<br>", colnames(sum_area))
knitr::kable(t(round(sum_area, 2)))
```

:::


::: {.panel-tabset}

## boxplot 

```{r}
#| label: fig-boxperimstudy
#| fig-cap: "Field perimeter in m per project. The dashed line show the median perimeter."

par(mar = c(8, 4, 4, 1))
boxplot(
  indv$Perim_m ~ indv$Study_Lab,
  las = 2,
  ylab = "m",
  xlab = "",
  main = "Crop field perimeter",
)
abline(h = median(indv$Perim_m, na.rm = TRUE), lwd = 2, lty = 3)
```

## table
```{r}
#| label: tbl-perimstudy
#| tbl-cap: "Summary statistics per project of the perimeter (in m) of crop fields"
sum_area <- sapply(
  tapply(indv$Perim_m, indv$Study_ID, summary),
  function(x) x[1:6]
)
# remove DURUM_MIX_GM
sum_area <- sum_area[, !is.na(sum_area[1, ])]

#colnames(sum_area) <- gsub("_", "<br>", colnames(sum_area))
knitr::kable(t(round(sum_area, 2)))
```

:::



```{r}
#| label: fig-areaperim
#| fig-cap: "Relation between area and perimeter (in log scale)"
# sunflowerplot(
#   indv$Area_ha,
#   indv$Perim_m,
#   xlab = "Area (ha)",
#   ylab = "Perimeter (m)"
# )
plot(
  indv$Area_ha,
  indv$Perim_m,
  xlab = "Area (ha)",
  ylab = "Perimeter (m)",
  log = "xy"
)
```

There is a strong relation between area and perimeter (@fig-areaperim). In median, field size is ```r round(median(indv$Area_ha, na.rm=TRUE),1)``` ha and field perimeter is ```r round(median(indv$Perim_m, na.rm=TRUE),0)```m.  

**Outliers**

```{r}
# for matching image to satellite image
ind23 <- indv[indv$Year == 2023, ]
```

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-highperim
#| fig-cap: "Field with large perimeter"
#fmt: skip
maxF <- rpg_fields[rpg_fields$ID_PARCEL == ind23$ID_PARCEL[which.max(ind23$Perim_m)]]
maxP <- pts[pts$ID == ind23$ID[which.max(ind23$Perim_m)]]
mapview(maxF) + mapview(maxP) # not up to date
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-smallarea
#| fig-cap: "Field with small area"
#fmt: skip
minF <- rpg_fields[rpg_fields$ID_PARCEL == ind23$ID_PARCEL[which.min(ind23$Area_ha)]]
minP <- pts[pts$ID == ind23$ID[which.min(ind23$Area_ha)]]
mapview(minF) + mapview(minP) # not up to date
```

:::

::::

**To be discussed:**  

- Some fields are defined as ```r ref$nom[ref$original_code == "BOR"]``` which are not proper fields but borders (as in @fig-smallarea). Should we remove non crop fields from RPG before running the calculations (e.g. `Bordure`, `Bande tampon`, `Surface non agricole`, `Truffière`, `Bois paturés`)?


### Hedgerows length

Using the field as defined in `RPG`, we calculated the length of hedgerows from `BD Haies` that intersect the field (+ a small buffer).

```{r}
#| label: tbl-haiebuffer
#| tbl-cap: "Summary statistics of the hedgerows length (in m) within different buffer size around the field"
buff_hedge <- cbind(
  "B_0m" = summary(indv$Length_haie_0_m),
  "B_5m" = summary(indv$Length_haie_5_m),
  "B_10m" = summary(indv$Length_haie_10_m)
)

#fmt: skip
PercWithHedgerows <- c(
  sum(indv$Length_haie_0_m > 0, na.rm = TRUE),
  sum(indv$Length_haie_5_m > 0, na.rm = TRUE),
  sum(indv$Length_haie_10_m > 0, na.rm = TRUE)
) / sum(!is.na(indv$Length_haie_0_m)) * 100

buff_hedge <- rbind(buff_hedge, PercWithHedgerows)

knitr::kable(round(buff_hedge, 2))
```

The ```r buff_hedge["NA's",1]``` NA's correspond to the observations from which no corresponding fields were found. Without buffer, ```r round(PercWithHedgerows[1])```% of fields have hedgerows within the field. This percentage increases up to ```r round(PercWithHedgerows[3])```% if we consider a 10m buffer around the field.  

```{r}
#| label: fig-corhaie
#| fig-cap: "Correlation among hedgerows lengths per buffer size"
hedgelendth <- data.frame(
  "B_0m" = indv$Length_haie_0_m,
  "B_5m" = indv$Length_haie_5_m,
  "B_10m" = indv$Length_haie_10_m
)

pairs(hedgelendth, lower.panel = panel.smooth, upper.panel = panel.cor)
```

**Outliers**

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-outhaie5
#| fig-cap: "Field with hedgerows at 5m buffer"
#fmt: skip
ex1 <- which(indv$ID == indv$ID[indv$Length_haie_0_m == 0][which.max(indv$Length_haie_10_m[indv$Length_haie_0_m == 0])])
pts_ex1 <- pts[pts$ID == indv$ID[ex1]]
rpg_ex1 <- rpg_fields[rpg_fields$ID_PARCEL == indv$ID_PARCEL[ex1]]
r5_ex1 <- buffer(rpg_ex1, 5)
r10_ex1 <- buffer(rpg_ex1, 10)
haie_ex1 <- vect(
  here("data", "raw-data", "haie_2-0.gpkg"),
  filter = vect(ext(r10_ex1))
)

plot(r10_ex1, col = NA, border = "red", lty = 3, main = indv$ID[ex1])
plot(rpg_ex1, col = NA, border = "black", add = TRUE)
plot(r5_ex1, col = NA, border = "blue", lty = 2, add = TRUE)
plot(haie_ex1, col = "darkgreen", lwd = 3, add = TRUE)
plot(project(pts_ex1, crs(haie_ex1)), add = TRUE)
lab <- c(
  paste("B_0m:", round(indv$Length_haie_0_m[ex1]), "m"),
  paste("B_5m:", round(indv$Length_haie_5_m[ex1]), "m"),
  paste("B_10m:", round(indv$Length_haie_10_m[ex1]), "m")
)
legend(
  "topright",
  legend = lab,
  col = c("black", "blue", "red"),
  lty = 1:3,
  xpd = NA
)

```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-outhaie10
#| fig-cap: "Field with hedgerows at 10m buffer"
#fmt: skip
ex2 <- which(indv$ID == indv$ID[indv$Length_haie_5_m == 0][which.max(indv$Length_haie_10_m[indv$Length_haie_5_m == 0])])
pts_ex2 <- pts[pts$ID == indv$ID[ex2]]
rpg_ex2 <- rpg_fields[rpg_fields$ID_PARCEL == indv$ID_PARCEL[ex2]]
r5_ex2 <- buffer(rpg_ex2, 5)
r10_ex2 <- buffer(rpg_ex2, 10)
haie_ex2 <- vect(
  here("data", "raw-data", "haie_2-0.gpkg"),
  filter = vect(ext(r10_ex2))
)

plot(r10_ex2, col = NA, border = "red", lty = 3, main = indv$ID[ex2])
plot(rpg_ex2, col = NA, border = "black", add = TRUE)
plot(r5_ex2, col = NA, border = "blue", lty = 2, add = TRUE)
plot(haie_ex2, col = "darkgreen", lwd = 3, add = TRUE)
plot(project(pts_ex2, crs(haie_ex2)), add = TRUE)
lab <- c(
  paste("B_0m:", round(indv$Length_haie_0_m[ex2]), "m"),
  paste("B_5m:", round(indv$Length_haie_5_m[ex2]), "m"),
  paste("B_10m:", round(indv$Length_haie_10_m[ex2]), "m")
)
legend(
  "topright",
  legend = lab,
  col = c("black", "blue", "red"),
  lty = 1:3,
  xpd = NA
)

```

:::

::::

**To be discussed:**    

- Which buffer size should we use to calculate the hedgerows lengths? Without buffer, it might be too restrictive, but is 10m too large, or not enough?  
- Should we consider the location of the sampling when calculating the hedgerows length?  


### Field size within buffer
    
Using the coordinates of the sampling sites, we calculated the average area of all crop fields within a buffer (500m, 1000m, and 1500m).

```{r}
#| label: tbl-fsizebuffer
#| tbl-cap: "Summary statistics of the field area (in ha) within different buffer size"
buff_size <- cbind(
  "B_500m" = summary(indv$Mean_fieldsize_500m_ha),
  "B_1000m" = summary(indv$Mean_fieldsize_1000m_ha),
  "B_1500m" = summary(indv$Mean_fieldsize_1500m_ha)
)

knitr::kable(round(buff_size, 2))
```

We see that some observations don't have crop field within 500m (N=13). These observations (listed in @tbl-nofield500) would need to be checked and ensure that they are close to an agricultural field.  

```{r}
#| label: tbl-nofield500
#| tbl-cap: "Observations with no fields within a 500m buffer."
# table(indv$Study_ID, is.na(indv$Mean_fieldsize_500m_ha))
miss_b500 <- indv[is.na(indv$Mean_fieldsize_500m_ha), ]
miss_b500[
  order(miss_b500$Study_ID, miss_b500$Year),
  c("Study_ID", "Site", "Year")
] |>
  knitr::kable()
```



::: {.panel-tabset}

## 500m 

```{r}
#| label: fig-fsize500
#| fig-cap: "Average field size with buffer of 500m"

par(mar = c(8, 4, 4, 1))
boxplot(
  indv$Mean_fieldsize_500m_ha ~ indv$Study_Lab,
  las = 2,
  ylab = "ha",
  xlab = "",
  main = "Average field size within 500m buffer"
)
abline(h = median(indv$Mean_fieldsize_500m_ha, na.rm = TRUE), lwd = 2, lty = 3)
```

## 1000m 

```{r}
#| label: fig-fsize1000
#| fig-cap: "Average field size with buffer of 1000m"

par(mar = c(8, 4, 4, 1))
boxplot(
  indv$Mean_fieldsize_1000m_ha ~ indv$Study_Lab,
  las = 2,
  ylab = "ha",
  xlab = "",
  main = "Average field size within 1000m buffer"
)
abline(h = median(indv$Mean_fieldsize_1500m_ha, na.rm = TRUE), lwd = 2, lty = 3)
```

## 1500m 

```{r}
#| label: fig-fsize1500
#| fig-cap: "Average field size with buffer of 1500m"

par(mar = c(8, 4, 4, 1))
boxplot(
  indv$Mean_fieldsize_1500m_ha ~ indv$Study_Lab,
  las = 2,
  ylab = "ha",
  xlab = "",
  main = "Average field size within 1500m buffer"
)
abline(h = median(indv$Mean_fieldsize_1500m_ha, na.rm = TRUE), lwd = 2, lty = 3)
```

:::





```{r}
#| label: fig-corfsize
#| fig-cap: "Correlation among field areas per buffer size"
meansize <- data.frame(
  "B_500m" = indv$Mean_fieldsize_500m_ha,
  "B_1000m" = indv$Mean_fieldsize_1000m_ha,
  "B_1500m" = indv$Mean_fieldsize_1500m_ha
)

pairs(meansize, lower.panel = panel.smooth, upper.panel = panel.cor)
```

**Outliers**

::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-highfsize
#| fig-cap: "Highest average field size within 1500m buffer"
#fmt: skip
ex1 <-  which(indv$ID == indv$ID[indv$Year == 2023][which.max(indv$Mean_fieldsize_1500m_ha[indv$Year == 2023])])

pts_ex1 <- project(pts[pts$ID == indv$ID[ex1]], crs(haie_ex1))
b500_ex1 <- buffer(pts_ex1, 500)
b1000_ex1 <- buffer(pts_ex1, 1000)
b1500_ex1 <- buffer(pts_ex1, 1500)

rpg_ex1 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex1
)

plot(rpg_ex1, col = NA, border = "black", main = indv$ID[ex1])
plot(b1500_ex1, col = NA, border = "red", add = TRUE)
plot(b1000_ex1, col = NA, border = "blue", add = TRUE)
plot(b500_ex1, col = NA, border = "green", add = TRUE)
plot(pts_ex1, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex1], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex1], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex1], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-lowfsize
#| fig-cap: "Lowest average field size within 1500m buffer"
#fmt: skip
ex2 <-  which(indv$ID == indv$ID[indv$Year == 2023][which.min(indv$Mean_fieldsize_1500m_ha[indv$Year == 2023])])

pts_ex2 <- project(pts[pts$ID == indv$ID[ex2]], crs(haie_ex2))
b500_ex2 <- buffer(pts_ex2, 500)
b1000_ex2 <- buffer(pts_ex2, 1000)
b1500_ex2 <- buffer(pts_ex2, 1500)

rpg_ex2 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex2
)

plot(rpg_ex2, col = NA, border = "black", main = indv$ID[ex2])
plot(b1500_ex2, col = NA, border = "red", add = TRUE)
plot(b1000_ex2, col = NA, border = "blue", add = TRUE)
plot(b500_ex2, col = NA, border = "green", add = TRUE)
plot(pts_ex2, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex2], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex2], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex2], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

::::


::::{ .columns }
:::{ .column width="50%"}

```{r}
#| label: fig-deltafsize1500
#| fig-cap: "Large differences between 1000 and 1500m buffer"
var1 <- abs(indv$Mean_fieldsize_1500m_ha - indv$Mean_fieldsize_1000m_ha) /
  (indv$Mean_fieldsize_1500m_ha + indv$Mean_fieldsize_1000m_ha)

whom <- indv$Year == 2023 & !is.na(indv$ID_PARCEL)
ex3 <- which(indv$ID == indv$ID[whom][which.max(var1[whom])])

pts_ex3 <- project(pts[pts$ID == indv$ID[ex3]], "EPSG:2154")
b500_ex3 <- buffer(pts_ex3, 500)
b1000_ex3 <- buffer(pts_ex3, 1000)
b1500_ex3 <- buffer(pts_ex3, 1500)

rpg_ex3 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex3
)

plot(rpg_ex3, col = NA, border = "black", main = indv$ID[ex3])
plot(b1500_ex3, col = NA, border = "red", add = TRUE)
plot(b1000_ex3, col = NA, border = "blue", add = TRUE)
plot(b500_ex3, col = NA, border = "green", add = TRUE)
plot(pts_ex3, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex3], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex3], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex3], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

:::{ .column width="50%"}
```{r}
#| label: fig-deltafsize1000
#| fig-cap: "Large differences between 500 and 1000m buffer"
var2 <- abs(indv$Mean_fieldsize_1500m_ha - indv$Mean_fieldsize_500m_ha) /
  (indv$Mean_fieldsize_1500m_ha + indv$Mean_fieldsize_500m_ha)

whom <- indv$Year == 2023 &
  !is.na(indv$ID_PARCEL) &
  indv$Study_ID != indv$Study_ID[ex3]
ex4 <- which(indv$ID == indv$ID[whom][which.max(var2[whom])])

pts_ex4 <- project(pts[pts$ID == indv$ID[ex4]], "EPSG:2154")
b500_ex4 <- buffer(pts_ex4, 500)
b1000_ex4 <- buffer(pts_ex4, 1000)
b1500_ex4 <- buffer(pts_ex4, 1500)

rpg_ex4 <- vect(
  here("data", "raw-data", "RPG", "RPG_2-2_2023_PARCELLES_GRAPHIQUES.gpkg"),
  filter = b1500_ex4
)

plot(rpg_ex4, col = NA, border = "black", main = indv$ID[ex4])
plot(b1500_ex4, col = NA, border = "red", add = TRUE)
plot(b1000_ex4, col = NA, border = "blue", add = TRUE)
plot(b500_ex4, col = NA, border = "green", add = TRUE)
plot(pts_ex4, add = TRUE)
lab <- c(
  paste("B_500m:", round(indv$Mean_fieldsize_500m_ha[ex4], 2), "ha"),
  paste("B_1000m:", round(indv$Mean_fieldsize_1000m_ha[ex4], 2), "ha"),
  paste("B_1500m:", round(indv$Mean_fieldsize_1500m_ha[ex4], 2), "ha")
)
legend(
  "bottomleft",
  legend = lab,
  col = c("green", "blue", "red"),
  lty = 1,
  xpd = NA
)
```

:::

::::


### Summary and questions about vector indicators   

- Most observations have a corresponding crop field in RPG dataset (@tbl-inrpg).    
- But some coordinates were taken at the outside edge of the field (@fig-outsebiopagvcg), so we might need to identify the closest field instead (and add a distance threshold, e.g. 10m).  
- Adding the `RPG complété` requires more data processing and it won't cover all observations (but it will help characterizing some wineyards that are not registered in the PAC). The `RPG complété` classes might be less consistent within our timeframe (e.g. issue with data from 2016-2017) so it would require further checks.
- We might need to exclude some fields from RPG (e.g. `Bordure`, `Bande tampon`, `Surface non agricole`, `Truffière`, `Bois paturés`) to includes only crop fields that are relevant for us. This information should be added in the file [RPG-OSO_classes.csv](https://github.com/FunBioDiv/gis-diversification/raw/refs/heads/main/data/derived-data/RPG-OSO_classes.csv).
- The sampling location within the field might influence the results (different impact of hedgerows, or of agricultural practices). We might want to add an indicator reflecting the distance to the center of the field and/or the distance to the closest field boundary?  


## Indicators from raster datasets (RPG+OSO)

Annual rasters with a 10m spatial resolution were created based on (1) RPG information and, where missing, (2) OSO dataset. We used these RPG+OSO rasters to extract information on crop rotation, land cover within buffer and edge density.   


### Crop rotation (N-5:N)

```{r}
# make small correspondance table
ref$fullname <- paste(ref$source, ref$nom, sep = "_")
miniref <- ref[, c("new_code", "fullname")]
miniref <- miniref[!duplicated(miniref$new_code), ]
miniref <- miniref[!is.na(miniref$new_code), ]
miniref$fullname <- gsub("OSO_old_", "OSO_", miniref$fullname)

# transform with class names
lulc_id <- indr[, grep("lulc_", names(indr))]
lulc_class <- sapply(lulc_id, function(x) {
  miniref$fullname[match(x, miniref$new_code)]
})
lulc_group <- sapply(lulc_id, function(x) {
  ref$grp_label[match(x, ref$new_code)]
})

indr$Study_ID <- pts$Study_ID[match(indr$ID, pts$ID)]
indr$Site <- pts$Site[match(indr$ID, pts$ID)]
indr$Year <- pts$Year[match(indr$ID, pts$ID)]

nyear <- apply(lulc_id, 1, function(x) length(x[!is.na(x)]))
ncrop <- apply(lulc_id, 1, function(x) length(unique(x[!is.na(x)])))
ngroup <- apply(lulc_group, 1, function(x) length(unique(x[!is.na(x)])))
```


```{r}
#| label: tbl-coverdata
#| tbl-cap: "Land cover data sources for the observations at year N to N-5"

info <- data.frame(
  "inRPG" = apply(lulc_id < 20000, 2, sum, na.rm = TRUE),
  "inOSO" = apply(lulc_id >= 20000, 2, sum, na.rm = TRUE),
  "NAs" = apply(is.na(lulc_id), 2, sum)
)
row.names(info)[-1] <- gsub("_N", "_N-", row.names(info)[-1])
knitr::kable(info)

# barplot(as.matrix(t(info)))
```

The number of NAs in @tbl-coverdata is a results of the number of observations per year (@tbl-yearstudy). For instance at year N, there are NAs for observations carried out in 2014, 2015, and 2024. For year N-1, the NAs correspond to observations carried out in 2014, 2015, and 2016.  


```{r}
#| label: tbl-coverclass
#| tbl-cap: "Most commun land cover classes"
lulc_vec <- as.character(unlist(lulc_class[, 1])) #[,1]
info <- sort(table(lulc_vec), decreasing = TRUE)
info <- data.frame(info[1:sum(info > 20)])
names(info) <- c("landcover class", "N")
knitr::kable(info)
```

```{r}
#| label: fig-coverstudy
#| fig-cap: "Land cover of the observations (at year N) per project"

nlulc <- data.frame(table(lulc_group[, 1], indr$Study_ID))
names(nlulc) <- c("Cover", "Project", "Nobs")
plot_ly(
  nlulc,
  x = ~Project,
  y = ~Nobs,
  color = ~Cover,
  text = ~Cover,
  colors = pals::glasbey(lunique(nlulc$Cover)),
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack") %>%
  config(modeBarButtons = list(list("toImage")), displaylogo = FALSE)
```

Vigne is the most common land cover (@tbl-coverclass), but the information might come from `RPG` (two classes: `Vigne (sauf vigne rouge)` and `Vigne : raisins de cuve non en production`) or `OSO`. The land cover depends greatly on the project (@fig-coverstudy) with `OSCAR` and `BACCHUS` studying wineyards, `FRAMEwork` and `SBIOPAG` studying orchard, and the other projects focusing on annual crops.  

Let's have a look at the crop rotations over the 6-year period (N:N-5).  


```{r}
#| label: fig-nyearstudy
#| fig-cap: "Length of the land cover time series per project."

# barplot(
#   table(nyear),
#   xlab = "Number of years with land cover",
#   ylab = "Number of observations",
#   col = c(rep("grey70", 6), "black")
# )
nyeardb <- data.frame(table(nyear, indr$Study_ID))
names(nyeardb) <- c("NYear", "Dataset", "Nobs")
plot_ly(
  nyeardb,
  x = ~NYear,
  y = ~Nobs,
  color = ~Dataset,
  text = ~Dataset,
  colors = pals::glasbey(lunique(nyeardb$Dataset)),
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack") %>%
  config(modeBarButtons = list(list("toImage")), displaylogo = FALSE)

```

::: {.panel-tabset}

## crop group
```{r}
#| label: fig-ngrprot
#| fig-cap: "Number of different crop groups cultivated in the period N:N-5. Only observations with complete information on land cover for the 6 years are included."
ngroup_db <- data.frame(table(ngroup[nyear == 6], indr$Study_ID[nyear == 6]))
names(ngroup_db) <- c("Ngroup", "Dataset", "Nobs")
plot_ly(
  ngroup_db,
  x = ~Ngroup,
  y = ~Nobs,
  color = ~Dataset,
  text = ~Dataset,
  colors = pals::glasbey(lunique(ngroup_db$Dataset)),
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack") %>%
  config(modeBarButtons = list(list("toImage")), displaylogo = FALSE)

# barplot(
#   table(ngroup[nyear == 6]),
#   xlab = "Number of crop groups in N:N-5",
#   ylab = "Number of observations"
# )

# info <- table(ngroup[nyear == 6], indr$Study_ID[nyear == 6])
# knitr::kable(t(info), row.names = TRUE)
```

## crop 
```{r}
#| label: fig-ncroprot
#| fig-cap: "Number of different crop groups cultivated in the period N:N-5. Only observations with complete information on land cover for the 6 years are included."
ncrop_db <- data.frame(table(ncrop[nyear == 6], indr$Study_ID[nyear == 6]))
names(ncrop_db) <- c("Ncrop", "Dataset", "Nobs")
plot_ly(
  ncrop_db,
  x = ~Ncrop,
  y = ~Nobs,
  color = ~Dataset,
  text = ~Dataset,
  colors = pals::glasbey(lunique(ncrop_db$Dataset)),
  textposition = "none",
  hoverinfo = "x+y+text"
) %>%
  add_bars() %>%
  layout(barmode = "stack") %>%
  config(modeBarButtons = list(list("toImage")), displaylogo = FALSE)

# barplot(
#   table(ncrop[nyear == 6]),
#   xlab = "Number of crops in N:N-5",
#   ylab = "Number of observations"
# )
```

:::

There are ```r sum(nyear == 6)``` observations with complete time series from year N to N-5 (@fig-nyearstudy). From these observations with complete crop rotation information, ```r sum(ngroup[nyear == 6] == 1)``` have the same crop group for the whole time period, while ```r sum(ngroup[nyear == 6] == 4)``` fields have four different crop groups in the past 6 years (@fig-ngrprot).


```{r}
# comparaison landN vs indV
code_rpg <- indv$CODE_CULTU[match(indr$ID, indv$ID)]
lulc_rpg <- ref$new_code[match(code_rpg, ref$original_code)]
# table(indr$lulc_N == lulc_rpg, useNA = "ifany")
# table(indr$lulc_N == lulc_rpg, useNA = "ifany")
# 33 out of 1045 : 3% = OK

# wrong <- which(indr$lulc_N != lulc_rpg)
# df <- data.frame(
#   "ID" = indr$ID,
#   "lulc_raster" = indr$lulc_N,
#   "rast_label" = ref$nom[match(indr$lulc_N, ref$new_code)],
#   "rast_group" = ref$grp_label[match(indr$lulc_N, ref$new_code)],
#   "lulc_vector" = lulc_rpg,
#   "vect_label" = ref$nom[match(lulc_rpg, ref$new_code)],
#   "vect_group" = ref$grp_label[match(lulc_rpg, ref$new_code)]
# )
# df <- df[wrong, ]

# pts_wrong <- pts[match(df$ID, pts$ID)]
# pts_wrong <- cbind(pts_wrong, df)
# mapview(pts_wrong)
```




### Land cover within buffer 

```{r}
#| label: tbl-bcover
#| tbl-cap: "Summary of the land cover buffer composition"

m500 <- grep("frac500", names(indr))
l500 <- gsub("frac500_", "", names(indr)[m500])
gr500 <- t(rowsum(
  t(indr[, m500]),
  ref$grp_label[match(l500, ref$new_code)],
  na.rm = TRUE
))

m1000 <- grep("frac1000", names(indr))
l1000 <- gsub("frac1000_", "", names(indr)[m1000])
gr1000 <- t(rowsum(
  t(indr[, m1000]),
  ref$grp_label[match(l1000, ref$new_code)],
  na.rm = TRUE
))

m1500 <- grep("frac1500", names(indr))
l1500 <- gsub("frac1500_", "", names(indr)[m1500])
gr1500 <- t(rowsum(
  t(indr[, m1500]),
  ref$grp_label[match(l1500, ref$new_code)],
  na.rm = TRUE
))


p_rpg <- c(
  mean(rowSums(indr[, m500[l500 < 20000]], na.rm = TRUE)),
  mean(rowSums(indr[, m1000[l1000 < 20000]], na.rm = TRUE)),
  mean(rowSums(indr[, m1500[l1500 < 20000]], na.rm = TRUE))
)
p_rpg <- round(p_rpg * 100)

info <- data.frame(
  "n_classes" = c(length(m500), length(m1000), length(m1500)),
  "av_perc_rpg" = p_rpg
)
row.names(info) <- c("buffer_500", "buffer_1000", "buffer_1500")
knitr::kable(t(info))
```

::: {.panel-tabset}
## buffer size
```{r}
#| label: fig-coverbuffer
#| fig-cap: "Average land cover grouped in 36 categories per buffer size"
# number of classes per buffer

mean_buffer <- data.frame(
  "B500" = apply(gr500, 2, sum, na.rm = TRUE) / sum(rowSums(gr500) > 0),
  "B1000" = apply(gr1000, 2, sum, na.rm = TRUE) / sum(rowSums(gr1000) > 0),
  "B1500" = apply(gr1500, 2, sum, na.rm = TRUE) / sum(rowSums(gr1500) > 0)
)
# simp_buffer <- mean_buffer[rowSums(mean_buffer) > 0.01, ] |>
#   t() |>
#   as.data.frame()

plotly_df(data.frame(t(mean_buffer)), xlab = "Buffer size")
```

## year
```{r}
#| label: fig-coveryear
#| fig-cap: "Average land cover grouped in 36 categories per year"

py1500 <- data.frame(
  rowsum(gr1500, indr$Year, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr1500) > 0, indr$Year, sum))
)

plotly_df(py1500, xlab = "Year")

```

::: 

Without any grouping, there are ```r info[3,1]``` different categories covered by the 1500m buffers (@tbl-bcover). Theses categories need to be simplified before the land cover can be analyzed. The larger the buffer size, the higher is the number of different classes within the buffer.  

In average, roughly half of the buffer areas are filled with land cover classes from `RPG` (and the other half are `OSO` classes). The proportion of `RPG` classes slightly decreases with the size of the buffer (larger buffer includes less agricultural areas).

The average land cover within buffers among all observations is not really influenced by the size of the buffer (@fig-coverbuffer). The coverage are highly dynamics (no studies in wineyards in 2016-2017) so the average land cover do change drastically (@fig-coveryear). Yet some categories (`cultures d'été` and `culture d'hiver`) are only present in 2016-2017. A better way to look at land cover is to group them by study.


::: {.panel-tabset}

## 500m 

```{r}
#| label: fig-bcoverstudy500
#| fig-cap: "Average land cover per project with buffer of 500m"

pc500 <- data.frame(
  rowsum(gr500, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr500) > 0, indr$Study_ID, sum))
)

plotly_df(pc500)
```

## 1000m 

```{r}
#| label: fig-bcoverstudy1000
#| fig-cap: "Average land cover per project with buffer of 1000m"

pc1000 <- data.frame(
  rowsum(gr1000, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr1000) > 0, indr$Study_ID, sum))
)
# barplot(t(pc1000))
plotly_df(pc1000)
```

## 1500m 

```{r}
#| label: fig-bcoverstudy1500
#| fig-cap: "Average land cover per project with buffer of 1500m"

pc1500 <- data.frame(
  rowsum(gr1500, indr$Study_ID, na.rm = TRUE) /
    as.numeric(tapply(rowSums(gr1500) > 0, indr$Study_ID, sum))
)

plotly_df(pc1500)
```

:::

The land cover averages are highly different per study (@fig-bcoverstudy1500). The size of the buffer have little influence in the overall pattern. Yet increasing the size of the buffers tends to make the land cover more heterogeneous (higher eveness), the dominant class has a higher coverage with a buffer of 500m than 1500m.

### Edge density

*This section is still highly exploratory.* We considered two different kind of edges:  

- SNC: the edges between semi-natural land cover and agricutural crops
- RPG: the edges between different agricultural crops

We calculated the length of the edges within 1500m buffers and using the raster information at 10m, 20m, or 50m resolution.

```{r}
#| label: fig-exedges
#| fig-cap: "Illustration of the edge density calculations for the buffer of SEBIOPAG_ZAAr_R07_2021"

# edges <- edges[inde$Year > 2017, ]
# inde <- inde[inde$Year > 2017, ]
# pc1 <- ade4::dudi.pca(edges)
# inde$ID[which.min(rowSums(pc1$li**2))]
id <- "SEBIOPAG_ZAAr_R07_2021"

newclass <- ref[, c("new_code", "class_id")]
newclass <- newclass[!duplicated(newclass) & complete.cases(newclass), ]
labclass <- ref[, c("class_id", "class_label")]
labclass <- labclass[!duplicated(labclass) & complete.cases(labclass), ]

labref <- ref[, c("new_code", "nom")]
labref <- labref[!duplicated(labref$new_code) & complete.cases(labref), ]
labrm <- ref$nom[ref$class_label != "agriculture"]

# newgrp <- ref[, c("new_code", "grp_id")]
# newgrp <- newgrp[!duplicated(newgrp) & complete.cases(newgrp), ]
# labgrp <- ref[, c("grp_id", "grp_label")]
# labgrp <- labgrp[!duplicated(labgrp) & complete.cases(labgrp), ]

bi <- buffer(pts[pts$ID == id], 1500) |>
  project(crs(rpg_oso))
yri <- bi$Year
ri <- crop(rpg_oso[yri], bi, mask = TRUE)

par(mfrow = c(2, 3))

# SNC
ci <- classify(ri, newclass)
set.cats(ci, value = labclass)
c1 <- as.polygons(ci)
e_SNC_10m <- edges(c1, rm = "Impermeable")
c2 <- aggregate(ci, 2, fun = "modal") |> as.polygons()
e_SNC_20m <- edges(c2, rm = "Impermeable")
c5 <- aggregate(ci, 5, fun = "modal") |> as.polygons()
e_SNC_50m <- edges(c5, rm = "Impermeable")

plot(
  c1[c1$class_label != "Impermeable"],
  "class_label",
  main = paste("SNC_10m: ", round(perim(e_SNC_10m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_SNC_10m, add = TRUE, lwd = 2, col = "red")

plot(
  c2[c2$class_label != "Impermeable"],
  "class_label",
  main = paste("SNC_20m:", round(perim(e_SNC_20m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_SNC_20m, add = TRUE, lwd = 2, col = "red")

plot(
  c1[c1$class_label != "Impermeable"],
  "class_label",
  main = paste("SNC_50m: ", round(perim(e_SNC_50m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_SNC_50m, add = TRUE, lwd = 2, col = "red")

# RPG
set.cats(ri, value = labref)
r1 <- as.polygons(ri)
e_RPG_10m <- edges(r1, rm = labrm)
r2 <- aggregate(ri, 2, fun = "modal") |> as.polygons()
e_RPG_20m <- edges(r2, rm = labrm)
r5 <- aggregate(ri, 5, fun = "modal") |> as.polygons()
e_RPG_50m <- edges(r5, rm = labrm)

plot(
  r1[!r1$nom %in% labrm],
  "nom",
  main = paste("RPG_10m:", round(perim(e_RPG_10m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_RPG_10m, add = TRUE, lwd = 2, col = "red")

plot(
  r2[!r2$nom %in% labrm],
  "nom",
  main = paste("RPG_20m:", round(perim(e_RPG_20m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_RPG_20m, add = TRUE, lwd = 2, col = "red")

plot(
  r5[!r5$nom %in% labrm],
  "nom",
  main = paste("RPG_50m:", round(perim(e_RPG_50m) / 1000), "km"),
  legend = FALSE,
  border = NA,
)
plot(e_RPG_50m, add = TRUE, lwd = 2, col = "red")

```

::: {.panel-tabset}

## 10m 

```{r}
#| label: fig-boxsnc10
#| fig-cap: "Semi natural vs Crop edge density calculated at 10m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_SNC_10m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "SNC_10m",
)
abline(h = median(inde$e_SNC_10m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

## 20m
```{r}
#| label: fig-boxsnc20
#| fig-cap: "Semi natural vs Crop edge density calculated at 20m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_SNC_20m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "SNC_20m",
)
abline(h = median(inde$e_SNC_20m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

## 50m
```{r}
#| label: fig-boxsnc50
#| fig-cap: "Semi natural vs Crop edge density calculated at 50m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_SNC_50m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "SNC_50m",
)
abline(h = median(inde$e_SNC_50m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

:::


::: {.panel-tabset}

## 10m 

```{r}
#| label: fig-boxrpg10
#| fig-cap: "Crop edge density calculated at 10m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_RPG_10m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "RPG_10m",
)
abline(h = median(inde$e_RPG_10m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

## 20m
```{r}
#| label: fig-boxrpg20
#| fig-cap: "Crop edge density calculated at 20m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_RPG_20m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "RPG_20m",
)
abline(h = median(inde$e_RPG_20m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

## 50m
```{r}
#| label: fig-boxrpg50
#| fig-cap: "Crop edge density calculated at 50m resolution."

par(mar = c(8, 4, 4, 1))
boxplot(
  inde$e_RPG_50m / 1000 ~ inde$Study_Lab,
  las = 2,
  ylab = "km",
  xlab = "",
  main = "RPG_50m",
)
abline(h = median(inde$e_RPG_50m / 1000, na.rm = TRUE), lwd = 2, lty = 3)
```

:::



```{r}
#| label: fig-coredge
#| fig-cap: "Correlation among edge density"
edges <- inde[, 5:10]
edges <- sapply(edges, as.numeric)
pairs(edges, lower.panel = panel.smooth, upper.panel = panel.cor)
```



```{r}
#| label: fig-edgeyear
#| fig-cap: "Annual distribution of edge density calculated at 20m resolution"
par(mfrow = c(1, 2))
boxplot(
  inde$e_SNC_20m / 1000 ~ inde$Year,
  width = table(inde$Year),
  las = 2,
  ylab = "km",
  xlab = "",
  main = "SNC_20m",
)

boxplot(
  inde$e_RPG_20m / 1000 ~ inde$Year,
  width = table(inde$Year),
  las = 2,
  ylab = "km",
  xlab = "",
  main = "RPG_20m",
)

```


### Summary and questions about raster indicators:   

- Annual rasters combining RPG and OSO for the whole France simplify the extraction of indicators on crop rotations, proportion of land cover within buffers and edge length density. 

- There are up to ```r info$n_classes[3]``` land cover classes in the RPG+OSO dataset. Here we simplified it using the *Référentiel des cultures* (36 categories) as an illustration. Further work on land cover class homogeneization is needed to make use of the extracted information. This will be done independantly from the GIS data extraction.   

- The edge density needs further thinking to decide which kind of edges should be quantified, and at what scale. The spatial resolution depends on the minimum size of the patches that we want to consider.

- The OSO data for year 2016-2017 use different classes, e.g. crops are grouped into only two classes: `cultures d'été` and `culture d'hiver`. This might artificially inflate crop rotations (changes in land cover due to changes in GIS methodology instead of changes in crop practices) and it could potentially impact all indicators. Yet it is important to use *older* land cover if we want to characterize crop rotations on multiple years. 

- We could add `RPG complété` in the land cover rasters, but that might create discrepancies among classes and it would require additional care in the class homogeneization step.

- The resolution of 10m might be to rough for the caracterization of the crop fields. We might want to consider 5m or 2m spatial resolution (but we are also constrained by OSO).

